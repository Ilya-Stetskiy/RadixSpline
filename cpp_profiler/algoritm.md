# Пояснительная записка к RadixSpline
## Контекст задачи
Необходимо предложить алгоритм поиска позиции элемента в отсортированном массиве быстрее бинарного поиска 

Исходные данные: отсортированный по возрастанию массив целых, попарно различных значений, называемых ключами. `(key_1, ... ,key_n)` длины `n`

## Алгоритм RadixSpline
> Идея алгоритма заключается в том, чтобы "обучить" структуру на данных.

RadixSpline представляет из себя составную структуру для поиска элемента, состаящая из двух элементов, GreedySplineCorridor и Radix table: 
- GreedySplineCorridor - алгоритм представления данных  как набор апроксимарующих прямых с заданной целочисленной погрешностью ***err***. 
  - Строится жадно, за один последовательный проход по данным, 
  Возвращает массив пар значений, каждый элемент которых   (сплайнов), Все значения построенных прямых отличаются от индекса исходных данных не более чем на ***err*** 
  


### Алгоритм GreedySplineCorridor:

> Построение
> 
Входные данные алгоритма это массив отсортированных значений ``S``.  В алгоритме данные представляются как точки на плоскости с координатами S_i=(key_i, i), где i=1,...n, где key_i - "ключи" массива данных, i- порядковый "индекс ключа"
Обозначем заданную погрещность апроксимации `err`

Первую точку данных, называем точкой начала сплайна ``base_point``.

Берем вторую точку данных. По первым двум точкам данных S_1, S_2 проводим прямую. 
Находим два критических угла  ``p_max = p(base_point, (key_2,2+err))``, ``p_min=p(base_point, (key_2,2-err))``, задающие границы допустимого диапазона. 

Далее точки добавляются по одной, последовательно. 

**ЦИКЛ**

При добавлении новой точки `(key_i,i)` строится прямая из начала сплайна `base_point` до новой точки, 
и проверяется условие вхождения прямой в допустимый диапазон (``p_max ≥ p(base_point, (key_i,i)) ≥ p_min``).

**ЕСЛИ** условие выполняется
**ТО**
  1) переобозначаем критические углы ``p_max=min(p_max, p(base_point, (key_i,i+err))), p_min=max(p_min, p(base_point, (key_i,i-err)))``
  2) **Переход в начало цикла**

**ИНАЧЕ**
  1) Прямая апроксимации считается построенной до предыдущей точки  ``(base_point, S_(i-1))``
  2) Создаем новую прямую. Предыдущую точку считаем новой базовой, из неё находим критические углы к S_i
  3) **Переход в начало цикла**

В результате работы создается массив прямых(сплайнов), описывающих исходные данне.

> Поиск
 
Входной параметр: ключ искомой записи массива S

Выход: запись с искомым ключом.

1) Среди массива прямых находим ту, в которую входит искомый ключ (бинарным поиском)
2) математически вычисляем предположительную точку на прямой, где находится искомый ключ
3) Обращаемся к исходному набору данных и ищем необходимую запись в диапазоне `предположительная точка ± err`


### Radix table
- Radix table - разреженный индекс, который ссылается на блок результата GreedySplineCorridor.

    Разделение на блоки по префиксу длины ***bitlength***, это второй параметр для настройки RadixSpline
    В ячейках Radix Table лежат номера первых элементов, у которых префикс равен индексу ячейки

<table>
    <tr>
        <th>Индекс</th>
        <th>Ключ</th>
    </tr>
    <tr>
        <td>0</td>
        <td>00***</td>
    </tr>
    <tr>
        <td>1</td>
        <td>01***</td>
    </tr>
    <tr>
        <td>2</td>
        <td>10***</td>
    </tr>
    <tr>
        <td>3</td>
        <td>11***</td>
    </tr>
</table>

### Построение структуры
1) По данным строится GreedySplineCorridor.
2) По результату 1. строится индекс RadixTable

### Алгоритм поиска
1) Нахождение префикса полученного ключа
2) Переход к блоку данных по RadixTable 
3) Бинарный поиск внутри блока, для нахождения подходящей прямой апроксимации
4) Вычисление предположительной точки на прямой
5) Бинарный поиск по данным внутри диапазона ошибки



## Реализация
Greedy и RadixSpline реализованны отдельно, Greedy никак не зависит от Radix и может быть построен без Radix

### Greedy 
Строится жадно, данные в структуру добавляются функцией **new_spline**. Если структура пустая, происходит инициализация, где "критические прямые" уходят в бесконечность.
Затем, происходит проверка, описанная в алгоритме. Прямые представленны тангенсами углов. 
Поиск происходит по следующему алгоритму: пользователь вызывает get_key с парой ключ-значений (для проверки результата), в ней вызывается give_answer, которая возвращает предположительную точку на прямой, затем находится диапазон ошибки и проводится поиск внутри него
Результат (набор точек, образующие прямые) хранится в векторе greedyspline

Краткое описание реализованных функций: 
- new_spline функция добавление новых точек в структуру
- start установка начальных параметров 
- tg_spline функция для поиска тангенса угла наколна прямых
- new_coridor вычисляет коридор ошибки
- bin_search результат последнего бинарного поиска, итоговый результат поиска
- bin_search_spline бинарный поиск внутри блока, для нахождения подходящей прямой апроксиимации
- get_key функция для поиска элемента в структуре, с встроенной проверкой результата поиска (временно)
- give_answer поиск предположительной точки на прямой апроксимации

### Radix
Строится функцией get_RadixSpline за проход по вектору greedyspline, находя префиксы каждого элемента, и добавляя новые в разреженный индекс. 
Затем проходится в обратном порядке, заполняя пустые ячейки.

Сейчас реализованно следующее улучшение radixSpline: в случае, если все данные имеют одинаковый префикс, он находится функцией not_prefix_count, и в дальнейшем эта часть префикса не учитывается

При поиске элемента (get_key) вызывается give_ansver, которая находит необходимый блок апроксимирующих прямых  и вызывает поиск по данному блоку фунции выбранного сплайна, затем находится диапазон ошибки, и происходит поиск в нем.

Краткое описание реализованных функций:
- get_RadixSpline построение сплайна
- bit_length Находит длину числа в битовом формате
- not_prefix_count нахождение повторяющейся части в префиксе
- first_bits вычисление префикса
- give_answer нахождение блока прямых, вызов поиска внутри него
- get_key функция поиска

Помимо этого реализованна фукнция get_spline для генерации сплайнов.